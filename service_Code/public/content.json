[{"title":"Hello World","date":"2019-05-31T08:21:54.729Z","path":"2019/05/31/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"iOS高手课学习笔记","date":"2019-05-30T08:33:48.000Z","path":"2019/05/30/iOS高手课学习笔记/","text":"A说起 iOS 开发，自然是绕不开 iPhone 和 App Store 这两个词。 多少年过去了，我依然记得 2007 年乔布斯发布第一代 iPhone 时的场景， 可以说，那款 iPhone 重新定义了很多人对于手机的认知。 那一天，也是移动互联网时代的开端。 紧接着，在 2008 年 7 月的 WWDC 苹果全球开发者大会上， 苹果宣布 App Store 正式对外开放，这也意味着属于开发者的移动互联网时代真正开始了。 一转眼，十多年过去了，移动开发早已飞入寻常百姓家， 移动 App 基本成为了大众互联网产品的标配。 从技术角度看，这些年来移动开发领域相继诞生了组件化、热修复、动态化、大前端、Flutter、小程序等热门技术， 给人一种“乱花渐欲迷人眼”的感觉，它们争先恐后地成为行业焦点， 然后又在不知不觉中被后来者替代，最后再逐步淡出开发者的视野。 在我看来，这些技术看似过眼云烟，实则是递进式推动着移动技术的演进。 B这些技术看似“纷繁杂乱”，实则是殊途同归， 它们背后都是一些通用的底层技术和创新的设计思想。 比如，热修复、动态化和大前端的底层技术，都是 JavaScriptCore 这样的 JavaScript 虚拟机技术； 再比如，大前端和 Flutter 的渲染，使用的都是 WebCore 中 Skia 这样的渲染引擎。 所以，每当我串起来整体看移动开发领域这些年的这些“新”技术时，总是会感慨说“万变不离其宗”。 我就觉得如果我们能深入进去把某一门技术研究透彻，那再拿下其他的技术时就会变得轻车熟路。 C以组件化为例，它是顺应着 App 从单一业务到多业务汇聚的演进而出现的一门技术。 比如微信刚发布时业务单一，就只有聊天的功能， 后来又加上了支付、朋友圈、游戏，再等到小程序功能上线后更是打车、电影票、购物等只要你能想到的需求它都有， 俨然成为了一个超级平台。 从本质上讲，组件化是将上层业务隔离开，下层提供通用能力的一种架构模式， 这样上层业务团队可以分开从而减少团队沟通成本， 下层能力的通用性又反过来提高了各个业务团队的开发效率。 为了达到不同业务隔离的结果，解耦手段不断被引入到 iOS 开发中， 比如使用协议或者中间者模式在运行时统调等方式。 听到这里，你还会觉得组件化技术陌生吗？ 并不陌生，它的核心思想就是解耦。 只要你把这块研究透彻了，那再理解与解耦相关的其他技术架构也就水到渠成了。 D我们再以热修复为例，如果你看过相关的热修复技术源代码或者架构图的话， 应该不难发现热修复技术的核心引擎主要就是 JavaScriptCore， 它要求原生开发者使用 JavaScript 来编写代码。 而为了方便原生开发者，热修复引擎最大卖点就是将原生 Objective-C 代码转成 JavaScript 代码然后让 JavaScriptCore 去解释。 这样一个代码转换过程其实就是通过编译技术来实现的。 同时，在目前正流行的这波大前端和小程序浪潮中， 各种大前端技术都对 Web 标准做了大量限制， 定义了自己的规范模板。 这些自定义的模板最终都会使用 Babel 这样的前端编译技术将其编译成 JavaScript 代码， 然后再交给 JavaScriptCore 解释调用原生渲染。 所以，你看，只要掌握了热修复中的核心技术，就不难理解小程序的实现原理。 一切看起来就是那么自然。 E最近圈子里又开始流行 Flutter 了， 在 Flutter 这波浪潮还没有全面落地铺开前， 很多人就开始关心：下一个热点会是什么？ 其实我觉得大可不必在乎， 你只要静下心来好好消化掉这几年浪潮留下的关键技术， 在这个基础上再去理解各种“新技术”，必然会驾轻就熟。 F最后，再说个你最能切身体会的企业招聘对于 iOS 开发者的要求。 以前对工作经历只要求有过完整独立完成的 App 上架就够了，而现在如果你缺少大型项目经验，团队规模小， 没有好的提质提效开发经验，在应聘时的竞争力会大打折扣。 但，这并不是 iOS 领域的个体问题， 任何一个领域其实都和移动领域一样，从小型到大型，从个人到团队，从低效到高效，从凑合够用到高要求。 比如说，后端开发领域伴随着互联网的发展，也有过同样的经历。 你会发现，在一些公司从后端晋升到更高级别的开发者会更多些。 这就是因为后端开发领域很早就从小规模开发转变成了大规模开发， 在这个过程中已经整体经过了大量的演进， 对于开发人员的要求也在逐步提高， 特别是对系统架构的稳定和灵活设计能力的要求， 还有对工程质量和规范效率方面的高要求。 G我有幸深度经历了移动技术和后端技术的演进过程， 并在工作中进行了深度的调研和研究， 最终将成果落地到各个项目中。 在 iOS 技术发展的过程中， 我的知识也得到了递进式提升， 也最终被运用到了实际工作中， 比如组件化方案落地、大前端建设、应用开发阶段效率的提升、上线后各种难点问题的解决等。 在这个专栏里， 我会针对移动开发这些年演进过程中沉淀下来的那些技术， 那些支撑着 iOS 迈向更稳健、更成熟的技术进行详细而系统的输出。 同时，我也会提出自己的一些思考， 包括对于各种技术后面发展的方向和可能性的想法。 H接下来，我跟你说下专栏大致内容构成和写作思路。 移动开发面对的也是计算设备， 和后端一样也要监控和解决设备的内存和线程等性能问题， 编程的本质就是要解决问题，无论是需求、开发、调试、线上问题都需要编程来解决， 而代码是开发者的唯一武器。 所以，在第一部分的基础篇，我会围绕着如何解决 iOS 开发各个阶段的问题展开。 这是编程的基础，没有这个基础其他都免谈。 同时，解决问题的扎实程度，也决定了你在面试中的竞争力。 iOS 开发者更多的是面向用户界面和交互的开发， 而在界面、交互以及数据通信处理过程中存在大量的重复工作， 因此我会在第二部分的应用开发篇里，给你推荐一些经典好用的第三方库。 用好这些库，能够帮助你大幅提高应用开发的效率。 同时，我也会带你去探究这些优秀库的背后原理和实现思路， 当你面对千奇百怪的需求时，也能够开发出适合特定需求的库。 说不定下一个经典的第三方库就是由你开发的呢？ 如果你希望自己能在技术能力和职级上得到晋升， 在碰到问题时不再被动地见招拆招， 而是按照自己的套路主动出击化险为夷， 那么对于底层原理的深入学习就非常必要了。 在这个过程中，你还能学到前辈解决问题的思路， 这将让你收获颇丰。 所以，在第三部分的原理篇，我会专门针对一些底层原理， 比如 XNU、内存管理、编译等进行分享， 期待能够激发起你的学习兴趣，让你内力大增。 所谓良药苦口，底层知识的最初学习过程一定是辛苦的， 只有目标和意志非常坚定的那群人才能坚持下来。 但是，当你利用这些知识造出更好的轮子时， 那种成就感是你在舒适区获得的愉悦感无法比拟的。 iOS 开发技术的演进和前端是齐头并进的， 前端从开始的 H5 Hybrid 容器“陪跑姿态”转变为以 React Native 这样的技术为支撑的“助跑角色”， 还有 Flutter 这种新原生技术期待能够主导 iOS 的开发， 最后小程序这种产品形态主打生态牌， 而技术上返璞归真采用 Hybrid 技术又将前端技术重新拉回舞台。 面对现在这种原生与前端共舞的情景， 我会在第四部分帮你拆解各种技术细节， 以及它们之间的内在联系， 以便帮助你站在更高的视角去判断未来的技术走向和趋势。 晋升到更高位置的你，对未来技术走向的判断将尤为重要。 最后，我希望你能认真动手完成每篇文章后面的课后作业。 对于咱们手艺人来说，不动手都是空谈， 就像绘画教程，光看不练，是不会有进步的。 这就如同九阴真经的口诀，铭记于心后还需要常年累月的修炼才能精进。 动手就会碰到问题，就会思考，这个主动过程会加深你的记忆， 这样后面再碰到问题时，你会更容易将相关知识串联起来， 形成创新式的思考。 好了，今天的内容就到这里， 如果可以的话，还请你在留言区中做个自我介绍， 和我聊聊你目前的工作、学习情况，以及你在学习 iOS 开发时的痛点，这样我们可以彼此了解， 也方便我在后面针对性地给你讲解。 加油，让我们一起静下心，沉到具体的技术里，潜心研究。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Git学习笔记","date":"2019-05-30T08:23:28.000Z","path":"2019/05/30/Git学习笔记/","text":"","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"《iOS成长之路》读书笔记","date":"2018-10-16T04:09:59.000Z","path":"2018/10/16/《大神文章合集》读书笔记/","text":"写在前面的话： ==&gt;读书笔记之于我就是一个记录重点和知识线索提纲的作用 ==&gt;所以下文并不是通俗易懂的讲解，而是重点和知识线索的记录， ==&gt;如果你想阅读原文，请移步我的github. 请移步我的github 一，总体读书规划首先是整体的了解，也就是该书的目录“Chris Lattner 访谈录(下) 译者：@故胤道长，亚马逊 iOS 工程师，曾就职于 Uber。 博客：http://www.jianshu.com/u/8d5b91490ca5 动手玩 LLVM 作者：戴铭，滴滴出行技术专家。最近正在研究 iOS 编译相关底层技术，用来解决工程优化问题。 博客：https://ming1016.github.io/ Swift 性能分析 作者：唐巧，小猿搜题产品技术负责人，6 年 iOS 开发经验，《iOS开发进阶》作者。 博客：http://blog.devtang.com/about/ 监控SDK的架构设计 作者：王朝成， @圣迪 , 饿了么移动架构师。耕耘移动基础设施的建设，致力于移动大数据与人工智能的结合 博客：http://www.jianshu.com/u/a774b58c9b89 初识 LLVM 作者：@Alone_Monkey， 网易 iOS 工程师 博客：www.blogfshare.com TCP / IP 漫游 作者：@mrriddler，蚂蚁金服 iOS 工程师。 博客：blog.mrriddler.com 复用的精妙 - UITableView 复用技术原理分析 作者：冬瓜，微博：@冬瓜争做全栈瓜，爱奇艺 iOS 工程师。 博客：http://www.desgard.com 试图取代 TCP 的 QUIC 协议到底是什么 作者：张星宇，@bestswifter，百度 iOS 工程师，喜欢探索问题的本质，讨厌一切不说人话的描述。正在学习前端，励志成为一名大前端全栈工程师。 博客：https://bestswifter.com/ AFNetworking 源码分析 作者： @涂耀辉 ，今日头条 iOS 工程师 博客：http://www.jianshu.com/u/14431e509ae8 SpriteKit 入门与实践 作者：郭鹏，丁香园资深 iOS 工程师 基于 Rx 的网络层实践 作者：李富强，@李富强Jason，美团外卖 iOS 架构师 博客：http://blog.csdn.net/colorapp iOS 组件化 —— 路由设计思路分析 作者： @一缕殇流化隐半边冰霜，饿了么 iOS 工程师，微博 @halfrost 博客：http://www.jianshu.com/u/12201cdd5d7a iOS App 签名的原理 作者：bang，iOS 开发者，JSPatch 作者，做过推特中文圈和一些 iOS 独立应用，曾在腾讯工作，开发 QQ 邮箱与微信读书，现就职于蚂蚁金服。 博客：http://blog.cnbang.net 本书文章由： @故胤道长、 @一缕殇流化隐半边冰霜、 @没故事的卓同学、 @Onetaway 编辑。 我的读书计划是这样的从熟悉的到陌生的，逐步接触自己陌生的领域。 1，TCP / IP 漫游 2，AFNetworking 源码分析 3，复用的精妙 - UITableView 复用技术原理分析 4，iOS 组件化 —— 路由设计思路分析 5，监控SDK的架构设计 6，Swift 性能分析 7，iOS App 签名的原理 8，试图取代 TCP 的 QUIC 协议到底是什么 9，初识 LLVM 10，动手玩 LLVM 11，基于 Rx 的网络层实践 12，SpriteKit 入门与实践 一，TCP / IP 漫游根据数据在不同阶段的不同形式，我们可以把通常意义的网络7层协议或者网络5层协议归纳为4层协议。Application layer -&gt;HTTP 应用层 “数据的最终形式” Transport layer -&gt;TCP 传输层 “数据的字节(文本)形式” Internet layer -&gt;IP 网际层 “数据的二进制形式” Link layer -&gt;Ethernet 连接层 “数据的信号形式” 数据在发送通过这四层的时候，每经过一层会将数据作为Body，并加上这一层的控制信息作为header。而到达目的地后，再这通过四层时，每层会将相应的header剥离，最后给接收方一个与发送方发送的一模一样的数据。每一层都是通过控制header来控制数据传输的。 HTTP HTTP协议==&gt;协议字符串解析器。HTTP协议以字符串形式将数据解析、逆解析成请求行/响应行、请求头、请求体构成的报文。为什么说是字符串解析器呢？实际上，请求行、响应行、header甚至是分隔标识(CRLF)都是字符串。body就是数据，HTTP将数据的最终形式交由协议使用者来决定(text、xml、json等) TCP TCP是个实践性很强的协议，所以包含了很多的知识点。最基本最重要的特性==&gt;保证信息的可靠传输 ==&gt;可靠传输协议要求，双方的报文段(segment)必须都能无损的到达，并且发送方和接收方最后的报文段顺序需要一致。 ==&gt;报文段按顺序拼接组成报文。完好无损的报文才表示完整的数据传输完成。 ==&gt;报文段需要有序号来标识顺序 ==&gt;如果报文段受损或者发送方报文段根本没有到达接收方，发送方需要重传。 ==&gt;发送方启动一个计时器，计时器超时前没有收到信息接收方的确认信息，就认为报文没有到达接收方。 ==&gt;在发送自己的报文段的时候，顺便确认下所接受的报文段 ==&gt;面向连接，三次握手，四次挥手。 这个连接肯定不是建立物理上的连接，而是逻辑上建立了连接。连接也就指的是，发送方和接收方都要初始化一些状态会被用来跟踪(track)发送过程，也就说TCP是个有状态的协议，三次握手和四次挥手后面会聊。”","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"我的iOS开发进阶计划","date":"2018-10-15T04:08:03.000Z","path":"2018/10/15/我的iOS开发进阶计划/","text":"____时间过的真快，不知不觉，国庆长假已经过完，眼看着2018年就剩最后3个月了，心里甚是惶恐。今年伊始，我几经周折，终于搞定了换工作的事情，随后就是新公司的适应。期间零零散散的坐着iOS客户端功能的开发。公司的项目已经运营了好几年，目前主要是一些新的产品形态和运营活动的开发。结余时间，也试着研究了一下swift，前端开发和java语言，但都是浅尝辄止，并没有具备基本的开发能力。当然，大部分时间还是在看iOS相关的知识，但过于琐碎和晦涩的进阶的东西，让我无所适从，往往看一个问题会引出几个问题，最终的结果就好比猴子下山，丢了这个捡那个，丢了那个捡这个。经过这几个月的折腾，也没有明显感觉到自己的水平有令人印象深刻的变化。____今年是自己从事iOS开发的第三年了。从一个门外汉带入门，再到现在，一直感觉自己都是一个初级客户端开发者，每天写写基本的UI图，利用大神的框架与服务端协商获取数据并处理缓存，写一些函数处理业务逻辑和UI交互变化，然后利用百度解决一些从来没见过的问题和一些不知道处理了多少次还是要百度的问题。虽然期间会研究UI的绘图原理，尝试自己用代码绘制各种不同的非常规UI控件，研究核心动画并在交互中加入适当动画，研究网络相关的知识，比如：http和https，tcp与udp，webSocket等，尝试理解大神造的轮子，比如：AFNet，SDWeb等，但现在回想起来，却没有多少印象。我也不知道到底是我记忆力不够好，还是确实难以记忆。借用中学时老师的说法，一遍脑子记不住就用笔记下来，重复记忆是打败遗忘最好的方法。所以，我决定开始写自己的进阶计划和心得体会，目标是三个月后的元旦，我自己能真切感受到自己的进步。计划清单:第一部分：语言类1，作为iOS未来开发的必备语言，swift是必须要掌握的，尤其是4.0以来，swift语言趋向于稳定。 《The Swift Programming Language》 Swift 4.0 EditionSwift编程网函数式Swiftobjccn-swifter-tips2,为了拓宽自己的技术栈，使得自己不仅仅局限在iOS客户端开发，同时也增加自己学习新知识带来的快乐，要适当的涉猎前端开发和后端开发的知识。 所以，针对前端开发，要熟悉H5+JS+CSS，针对后端开发，要熟悉JAVA+数据库。 W3Cschool3,目前python这门语言的发展相当迅速，把它列为计划，其实我自己也不太清楚要干啥，这是之前看过一部分资料，希望这次有时间用python做点事情。 目前应用分发上传蒲公英的脚本就是用的python写的，6的不行。 跟老奇学python从入门到精通W3Cschool第二部分：大神库类那谁曾经说过，天下文章一大抄，看你会抄不会抄！经典的大神库，犹如沙漠中甘甜的泉水，滋润我干瘪的知识体系。网络：AFNetworking图片加载缓存：SDWebImage数据库：FMDB膜拜：YYKitM了个J：MJRefresh，MJExtensionUI：UITableView-FDTemplateLayoutCell布局：Masonry+SnapKit提示框：MBProgressHUD+SVProgressHUD第三部分：综合能力提升综合技能的提升不在于具体的知识点，而在于对软件编程的理解《代码大全》《Heard First 设计模式》《Effective OC 2.0：编写高质量iOS与OS X代码的52个有效方法》《深入理解计算机基础》《程序员的自我修养》第四部分：模块技能提升《图解HTTP》《大神扎堆》虽然在开发中也会是不是的使用动画，但真正谈论起iOS的动画，确实不怎么清楚。每次使用也是百度加自己摸索，没有一个系统的认识和了解。最近找到了两本好书，打算抽时间研究研究《iOS动画学习手册》《iOS Core Animation》计划赶不上变化，但万变不离其宗，每学习一个知识，都要写学习笔记列出一条主线，围绕主线展开，才能时刻知道自己在学什么。坚持在博客中写每个模块的学习笔记。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"The Swift Programming Language (4.0)(翻译)","date":"2018-09-11T08:39:26.000Z","path":"2018/09/11/The-Swift-Programming-Language-翻译/","text":"一直以来，我都想好好的研究研究一下这个新语言。之前虽然用过一段时间，但一直都觉得不甚了解。这本书已经得到了好久，期间也断断续续的读过，但我的英文水平有限，所以也就是看看示例代码而已。这次，又捡起这本书。想着可怜巴巴的英文水平，就想着借这个机会翻译翻译，即便是多数情况要借助翻译工具，但接触的多了，我的英文水平总该有所改善吧。同时又可以细化自己对这门语言的理解。记得有位大神说过：想让自己的水平提高，就试着写自己的博客吧。自己最早接触的语言是C，后来做iOS开发，学习了OC语言。对python，js和java有点模糊的认知。记得刚接触OC时，就无数次的接触这样一个名词：“面向对象”。在将近3年的开发经历中，一直都是使用OC。自从1年前开始接触swift，发现这个新语言真真的是好用。奈何现在公司的项目还没有考虑使用这门语言，所以，自己只能随便搞搞。最近的工作紧张起来，希望自己可以坚持翻译。Welcome to SwiftAbout Swift“Swift is a fantastic way to write software, whether it’s for phones, desktops, servers, or anything else that runs code. It’s a safe, fast, and interactive programming language that combines the best in modern language thinking with wisdom from the wider Apple engineering culture and the diverse contributions from its open-source community. The compiler is optimized for performance and the language is optimized for development, without compromising on either.”“Swift是编写软件的绝佳方式，无论是用于手机，台式机，服务器还是其他任何运行代码的软件。 它是一种安全，快速，交互式的编程语言，它将现代语言思维的最佳结合与来自更广泛的Apple工程文化的智慧和来自开源社区的各种贡献相结合。 编译器针对性能进行了优化，语言针对开发进行了优化，而且不会影响任何一个。”“Swift is friendly to new programmers. It’s an industrial-quality programming language that’s as expressive and enjoyable as a scripting language. Writing Swift code in a playground lets you experiment with code and see the results immediately, without the overhead of building and running an app.”“Swift对新程序员友好。 它是一种工业级编程语言，与脚本语言一样富有表现力和乐趣。 在游乐场中编写Swift代码可以让您试验代码并立即查看结果，而无需构建和运行应用程序的开销。”“Swift defines away large classes of common programming errors by adopting modern programming patterns:”“Variables are always initialized before use.Array indices are checked for out-of-bounds errors.Integers are checked for overflow.Optionals ensure that nil values are handled explicitly.Memory is managed automatically.Error handling allows controlled recovery from unexpected failures.”“Swift通过采用现代编程模式来定义大类常见的编程错误：”“变量总是在使用前初始化。 检查数组索引是否存在越界错误。 检查整数是否溢出。 Optionals确保明确处理nil值。 内存自动管理。 错误处理允许从意外故障中进行受控恢复。” “Swift code is compiled and optimized to get the most out of modern hardware. The syntax and standard library have been designed based on the guiding principle that the obvious way to write your code should also perform the best. Its combination of safety and speed make Swift an excellent choice for everything from “Hello, world!” to an entire operating system.”“Swift代码经过编译和优化，可以充分利用现代硬件。 语法和标准库的设计基于指导原则，即编写代码的明显方法也应该表现最佳。 它的安全性和速度相结合，使Swift成为从“Hello，world！”到整个操作系统的绝佳选择。”“Swift combines powerful type inference and pattern matching with a modern, lightweight syntax, allowing complex ideas to be expressed in a clear and concise manner. As a result, code is not just easier to write, but easier to read and maintain as well.”该语言使用强大的类型推断和现代的模式匹配功能，轻便的语法，“允许以清晰简洁的方式表达复杂的想法”，总而言之，代码不仅简单易读，而且容易维护。“Swift has been years in the making, and it continues to evolve with new features and capabilities. Our goals for Swift are ambitious. We can’t wait to see what you create with it.”“Swift多年来一直在不断发展，并且随着新特性和功能的不断发展而不断发展。 我们对Swift的目标雄心勃勃。 我们迫不及待地想看看你用它创造了什么。“Version Compatibility“This book describes Swift 4.0, the default version of Swift that’s included in Xcode 9. You can use Xcode 9 to build targets that are written in either Swift 4 or Swift 3.”“本书描述了Swift 4.0，它是Xcode 9中包含的Swift的默认版本。您可以使用Xcode 9构建以Swift 4或Swift 3编写的目标。”“When you use Xcode 9 to build Swift 3 code, most of the new Swift 4 functionality is available. That said, the following features are available only to Swift 4 code:Substring operations return an instance of the Substring type, instead of String.The @objc attribute is implicitly added in fewer places.Extensions to a type in the same file can access that type’s private members.“当您使用Xcode 9构建Swift 3代码时，大多数新的Swift 4功能都可用。 也就是说，以下功能仅适用于Swift 4代码：子串操作返回Substring类型的实例，而不是String。@objc属性隐式添加在更少的位置。对同一文件中的类型的扩展可以访问该类型的私有成员。“A target written in Swift 4 can depend on a target that’s written in Swift 3, and vice versa. This means, if you have a large project that’s divided into multiple frameworks, you can migrate your code from Swift 3 to Swift 4 one framework at a time.”“用Swift 4编写的目标可以依赖于用Swift 3编写的目标，反之亦然。 这意味着，如果您有一个分为多个框架的大型项目，您可以一次将代码从Swift 3迁移到Swift 4一个框架。”A Swift Tour“Tradition suggests that the first program in a new language should print the words “Hello, world!” on the screen. In Swift, this can be done in a single line:”print(&quot;Hello, world!&quot;) “If you have written code in C or Objective-C, this syntax looks familiar to you—in Swift, this line of code is a complete program. You don’t need to import a separate library for functionality like input/output or string handling. Code written at global scope is used as the entry point for the program, so you don’t need a main() function. You also don’t need to write semicolons at the end of every statement.”“如果你用C或Objective-C编写代码，这个语法看起来很熟悉 - 在Swift中，这行代码是一个完整的程序。 您无需为输入/输出或字符串处理等功能导入单独的库。 在全局范围编写的代码用作程序的入口点，因此您不需要main（）函数。 你也不需要在每个语句的末尾写分号。”“This tour gives you enough information to start writing code in Swift by showing you how to accomplish a variety of programming tasks. Don’t worry if you don’t understand something—everything introduced in this tour is explained in detail in the rest of this book.”“通过向您展示如何完成各种编程任务，本导览为您提供了足够的信息来开始在Swift中编写代码。 如果您不理解某些内容，请不要担心 - 本书其余部分将详细介绍本次导览中介绍的所有内容。”Simple Values“Use let to make a constant and var to make a variable. The value of a constant doesn’t need to be known at compile time, but you must assign it a value exactly once. This means you can use constants to name a value that you determine once but use in many places.”“var myVariable = 42 myVariable = 50 let myConstant = 42” “使用let来创建常量，使用var来创建变量。 在编译时不需要知道常量的值，但必须为其分配一次值。 这意味着您可以使用常量来命名您确定一次但在许多地方使用的值。”###### “A constant or variable must have the same type as the value you want to assign to it. However, you don’t always have to write the type explicitly. Providing a value when you create a constant or variable lets the compiler infer its type. In the example above, the compiler infers that myVariable is an integer because its initial value is an integer.” “常量或变量必须与要分配给它的值具有相同的类型。 但是，您并不总是必须明确地写入类型。 在创建常量或变量时提供值可让编译器推断其类型。 在上面的例子中，编译器推断myVariable是一个整数，因为它的初始值是一个整数。”“If the initial value doesn’t provide enough information (or if there is no initial value), specify the type by writing it after the variable, separated by a colon.”“如果初始值没有提供足够的信息（或者没有初始值），则通过在变量之后写入来指定类型，用冒号分隔。”“let implicitInteger = 70 let implicitDouble = 70.0 let explicitDouble: Double = 70” “Values are never implicitly converted to another type. If you need to convert a value to a different type, explicitly make an instance of the desired type.”“let label = &quot;The width is &quot; let width = 94 let widthLabel = label + String(width)” “There’s an even simpler way to include values in strings: Write the value in parentheses, and write a backslash () before the parentheses. For example:”“let apples = 3 let oranges = 5 let appleSummary = &quot;I have \\(apples) apples.&quot; let fruitSummary = &quot;I have \\(apples + oranges) pieces of fruit.” “Use three double quotes (“””) for strings that take up multiple lines. Indentation at the start of each quoted line is removed, as long as it matches the indentation of the closing quote. For example:”let quotation = &quot;&quot;&quot; Even though there&apos;s whitespace to the left, the actual lines aren&apos;t indented. Except for this line. Double quotes (&quot;) can appear without being escaped. I still have \\(apples + oranges) pieces of fruit. &quot;&quot;&quot; “Create arrays and dictionaries using brackets ([]), and access their elements by writing the index or key in brackets. A comma is allowed after the last element.”//arrays “var shoppingList = [&quot;catfish&quot;, &quot;water&quot;, &quot;tulips&quot;, &quot;blue paint&quot;] shoppingList[1] = &quot;bottle of water&quot; //dictionaries var occupations = [ &quot;Malcolm&quot;: &quot;Captain&quot;, &quot;Kaylee&quot;: &quot;Mechanic&quot;, ] occupations[&quot;Jayne&quot;] = &quot;Public Relations” “To create an empty array or dictionary, use the initializer syntax.”“let emptyArray = [String]() let emptyDictionary = [String: Float]()” “If type information can be inferred, you can write an empty array as [] and an empty dictionary as [:]—for example, when you set a new value for a variable or pass an argument to a function.”shoppingList = [] occupations = [:] ##“Control Flow Use if and switch to make conditionals, and use for-in, while, and repeat-while to make loops. Parentheses around the condition or loop variable are optional. Braces around the body are required.”使用if和switch来制作条件，并使用for-in，while和repeat-while来制作循环。 条件或循环变量周围的括号是可选的。 身体周围的{}是必需的。”“let individualScores = [75, 43, 103, 87, 12] var teamScore = 0 for score in individualScores { if score &gt; 50 { teamScore += 3 } else { teamScore += 1 } } print(teamScore)” “In an if statement, the conditional must be a Boolean expression—this means that code such as if score { … } is an error, not an implicit comparison to zero.”注意：这里与OC中的if的使用是不一样的。“You can use if and let together to work with values that might be missing. These values are represented as optionals. An optional value either contains a value or contains nil to indicate that a value is missing. Write a question mark (?) after the type of a value to mark the value as optional.”“var optionalString: String? = &quot;Hello&quot; print(optionalString == nil) var optionalName: String? = &quot;John Appleseed&quot; var greeting = &quot;Hello!&quot; if let name = optionalName { greeting = &quot;Hello, \\(name)&quot; }” “If the optional value is nil, the conditional is false and the code in braces is skipped. Otherwise, the optional value is unwrapped and assigned to the constant after let, which makes the unwrapped value available inside the block of code.”“如果可选值为nil，则条件为false，并跳过大括号中的代码。 否则，可选值被解包并在let之后分配给常量，这使得在代码块内可用解包值。”“Another way to handle optional values is to provide a default value using the ?? operator. If the optional value is missing, the default value is used instead.”“处理可选值的另一种方法是使用??提供默认值。 如果缺少可选值，则使用默认值。”“let nickName: String? = nil let fullName: String = &quot;John Appleseed&quot; let informalGreeting = &quot;Hi \\(nickName ?? fullName)” “Switches support any kind of data and a wide variety of comparison operations—they aren’t limited to integers and tests for equality.”“Switches支持任何类型的数据和各种各样的比较操作 - 它们不仅限于整数和相等的数值。”“let vegetable = &quot;red pepper&quot; switch vegetable { case &quot;celery&quot;: print(&quot;Add some raisins and make ants on a log.&quot;) case &quot;cucumber&quot;, &quot;watercress&quot;: print(&quot;That would make a good tea sandwich.&quot;) case let x where x.hasSuffix(&quot;pepper&quot;): print(&quot;Is it a spicy \\(x)?&quot;) default: print(&quot;Everything tastes good in soup.&quot;) }” 讲真，第一次看到这个的时候，我是无比激动的。“请注意如何在模式中使用let将模式匹配的值赋给常量。”“After executing the code inside the switch case that matched, the program exits from the switch statement. Execution doesn’t continue to the next case, so there is no need to explicitly break out of the switch at the end of each case’s code.”就是说不用在每个case里面再添加break了。“You use for-in to iterate over items in a dictionary by providing a pair of names to use for each key-value pair. Dictionaries are an unordered collection, so their keys and values are iterated over in an arbitrary order.”“通过提供一对用于每个键值对的名称，您可以使用for-in来迭代字典中的项目。 字典是一个无序集合，因此它们的键和值以任意顺序迭代。”“let interestingNumbers = [ &quot;Prime&quot;: [2, 3, 5, 7, 11, 13], &quot;Fibonacci&quot;: [1, 1, 2, 3, 5, 8], &quot;Square&quot;: [1, 4, 9, 16, 25], ] var largest = 0 for (kind, numbers) in interestingNumbers { for number in numbers { if number &gt; largest { largest = number } } } print(largest)” “Use while to repeat a block of code until a condition changes. The condition of a loop can be at the end instead, ensuring that the loop is run at least once.”“var n = 2 while n &lt; 100 { n *= 2 } print(n) var m = 2 repeat { m *= 2 } while m &lt; 100 print(m)” “You can keep an index in a loop by using ..&lt; to make a range of indexes.”“var total = 0 for i in 0..&lt;4 { total += i } print(total)” “Use ..&lt; to make a range that omits its upper value, and use … to make a range that includes both values.”Functions and Closures“Use func to declare a function. Call a function by following its name with a list of arguments in parentheses. Use -&gt; to separate the parameter names and types from the function’s return type.”“使用func声明一个函数。 通过在括号中使用参数列表跟随其名称来调用函数。 使用 - &gt;将参数名称和类型与函数的返回类型分开。”“func greet(person: String, day: String) -&gt; String { return &quot;Hello \\(person), today is \\(day).&quot; } greet(person: &quot;Bob&quot;, day: &quot;Tuesday&quot;)” “By default, functions use their parameter names as labels for their arguments. Write a custom argument label before the parameter name, or write _ to use no argument label.func greet(_ person: String, on day: String) -&gt; String { return &quot;Hello \\(person), today is \\(day).&quot; } greet(&quot;John&quot;, on: &quot;Wednesday&quot;)” “Use a tuple to make a compound value—for example, to return multiple values from a function. The elements of a tuple can be referred to either by name or by number.”“func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) { var min = scores[0] var max = scores[0] var sum = 0 for score in scores { if score &gt; max { max = score } else if score &lt; min { min = score } sum += score } return (min, max, sum) } let statistics = calculateStatistics(scores: [5, 3, 100, 3, 9]) print(statistics.sum) print(statistics.2)” “Functions can be nested. Nested functions have access to variables that were declared in the outer function. You can use nested functions to organize the code in a function that is long or complex.func returnFifteen() -&gt; Int { var y = 10 func add() { y += 5 } add() return y } returnFifteen()” “Functions are a first-class type. This means that a function can return another function as its value.”“func makeIncrementer() -&gt; ((Int) -&gt; Int) { func addOne(number: Int) -&gt; Int { return 1 + number } return addOne } var increment = makeIncrementer() increment(7)” 是不是各种骚操作满天飞“A function can take another function as one of its arguments.func hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool { for item in list { if condition(item) { return true } } return false } func lessThanTen(number: Int) -&gt; Bool { return number &lt; 10 } var numbers = [20, 19, 7, 12] hasAnyMatches(list: numbers, condition: lessThanTen)” “Functions are actually a special case of closures: blocks of code that can be called later. The code in a closure has access to things like variables and functions that were available in the scope where the closure was created, even if the closure is in a different scope when it is executed—you saw an example of this already with nested functions. You can write a closure without a name by surrounding code with braces ({}). Use in to separate the arguments and return type from the body.”“函数实际上是闭包的一种特殊情况：可以在以后调用的代码块。 闭包中的代码可以访问创建闭包的作用域中可用的变量和函数，即使闭包在执行时的不同作用域 - 您已经看到了嵌套函数的示例。 您可以使用大括号（{}）来编写没有名称的闭包。 用于将参数和返回类型与正文分开。”“numbers.map({ (number: Int) -&gt; Int in let result = 3 * number return result })” “You have several options for writing closures more concisely. When a closure’s type is already known, such as the callback for a delegate, you can omit the type of its parameters, its return type, or both. Single statement closures implicitly return the value of their only statement.let mappedNumbers = numbers.map({ number in 3 * number }) print(mappedNumbers)” “你有几种选择来更简洁地编写闭包。 当已知闭包的类型（例如委托的回调）时，可以省略其参数的类型，返回类型或两者。 单个语句闭包隐式返回其唯一语句的值。“You can refer to parameters by number instead of by name—this approach is especially useful in very short closures. A closure passed as the last argument to a function can appear immediately after the parentheses. When a closure is the only argument to a function, you can omit the parentheses entirely.let sortedNumbers = numbers.sorted { $0 &gt; $1 } print(sortedNumbers)” “您可以按编号而不是按名称来引用参数 - 这种方法在非常短的闭包中特别有用。 作为函数的最后一个参数传递的闭包可以在括号后面立即出现。 当闭包是函数的唯一参数时，可以完全省略括号。Objects and Classes“Use class followed by the class’s name to create a class. A property declaration in a class is written the same way as a constant or variable declaration, except that it is in the context of a class. Likewise, method and function declarations are written the same way.”“class Shape { var numberOfSides = 0 func simpleDescription() -&gt; String { return &quot;A shape with \\(numberOfSides) sides.&quot; } }” “使用类后跟类的名称来创建一个类。 类中的属性声明与常量或变量声明的编写方式相同，只是它位于类的上下文中。 同样，方法和函数声明也以相同的方式编写。”“Create an instance of a class by putting parentheses after the class name. Use dot syntax to access the properties and methods of the instance.var shape = Shape() shape.numberOfSides = 7 var shapeDescription = shape.simpleDescription()” “This version of the Shape class is missing something important: an initializer to set up the class when an instance is created. Use init to create one.class NamedShape { var numberOfSides: Int = 0 var name: String init(name: String) { self.name = name } func simpleDescription() -&gt; String { return &quot;A shape with \\(numberOfSides) sides.&quot; } }” “Notice how self is used to distinguish the name property from the name argument to the initializer. The arguments to the initializer are passed like a function call when you create an instance of the class. Every property needs a value assigned—either in its declaration (as with numberOfSides) or in the initializer (as with name).Use deinit to create a deinitializer if you need to perform some cleanup before the object is deallocated.Subclasses include their superclass name after their class name, separated by a colon. There is no requirement for classes to subclass any standard root class, so you can include or omit a superclass as needed.【Methods on a subclass that override the superclass’s implementation are marked with override—overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don’t actually override any method in the superclass.”】“class Square: NamedShape { var sideLength: Double init(sideLength: Double, name: String) { self.sideLength = sideLength super.init(name: name) numberOfSides = 4 } func area() -&gt; Double { return sideLength * sideLength } override func simpleDescription() -&gt; String { return &quot;A square with sides of length \\(sideLength).&quot; } } let test = Square(sideLength: 5.2, name: &quot;my test square&quot;) test.area() test.simpleDescription()” “注意self是如何用来区分name属性和name参数到初始化器的。创建类的实例时，初始化程序的参数就像函数调用一样传递。每个属性都需要一个赋值 - 在其声明中（与numberOfSides一样）或在初始化器中（与name一样）。如果需要在取消分配对象之前执行一些清理，请使用deinit创建一个deinitializer。子类在其类名后面包含它们的超类名称，用冒号分隔。类不需要子类化任何标准根类，因此您可以根据需要包含或省略超类。【覆盖超类的实现的子类上的方法标记为覆盖 - 覆盖方法意外，没有覆盖，编译器将其检测为错误。编译器还检测具有覆盖的方法，这些方法实际上不会覆盖超类中的任何方法。”】（这句话的理解，我水平有限，借助谷歌也就翻译成这样，如果大家能够很好的理解这段话，还烦请大家给我留言）“In addition to simple properties that are stored, properties can have a getter and a setter.”“class EquilateralTriangle: NamedShape { var sideLength: Double = 0.0 init(sideLength: Double, name: String) { self.sideLength = sideLength super.init(name: name) numberOfSides = 3 } var perimeter: Double { get { return 3.0 * sideLength } set { sideLength = newValue / 3.0 } } override func simpleDescription() -&gt; String { return &quot;An equilateral triangle with sides of length \\(sideLength).&quot; } } var triangle = EquilateralTriangle(sideLength: 3.1, name: &quot;a triangle&quot;) print(triangle.perimeter) triangle.perimeter = 9.9 print(triangle.sideLength)” “In the setter for perimeter, the new value has the implicit name newValue. You can provide an explicit name in parentheses after set.”“在set设置器中，新值具有隐含名称newValue。 您可以在设置后在括号中提供显式名称。”“Notice that the initializer for the EquilateralTriangle class has three different steps:Setting the value of properties that the subclass declares.Calling the superclass’s initializer.Changing the value of properties defined by the superclass. Any additional setup work that uses methods, getters, or setters can also be done at this point.”“If you don’t need to compute the property but still need to provide code that is run before and after setting a new value, use willSet and didSet. The code you provide is run any time the value changes outside of an initializer. For example, the class below ensures that the side length of its triangle is always the same as the side length of its square.class TriangleAndSquare { var triangle: EquilateralTriangle { willSet { square.sideLength = newValue.sideLength } } var square: Square { willSet { triangle.sideLength = newValue.sideLength } } init(size: Double, name: String) { square = Square(sideLength: size, name: name) triangle = EquilateralTriangle(sideLength: size, name: name) } } var triangleAndSquare = TriangleAndSquare(size: 10, name: &quot;another test shape&quot;) print(triangleAndSquare.square.sideLength) print(triangleAndSquare.triangle.sideLength) triangleAndSquare.square = Square(sideLength: 50, name: &quot;larger square&quot;) print(triangleAndSquare.triangle.sideLength)” “如果您不需要计算属性但仍需要提供在设置新值之前和之后运行的代码，请使用willSet和didSet。 您提供的代码在值在初始化程序之外更改时运行。 例如，下面的类确保其三角形的边长始终与其正方形的边长相同。“When working with optional values, you can write ? before operations like methods, properties, and subscripting. If the value before the ? is nil, everything after the ? is ignored and the value of the whole expression is nil. Otherwise, the optional value is unwrapped, and everything after the ? acts on the unwrapped value. In both cases, the value of the whole expression is an optional value.let optionalSquare: Square? = Square(sideLength: 2.5, name: &quot;optional square&quot;) let sideLength = optionalSquare?.sideLength” “使用可选值时，在诸如方法，属性和下标之类的操作之前你可以写？。 如果？之前的值是零，那么？之后的所有值都被忽略，整个表达式的值为零。 否则，可选值解包，并且后面的一切都是？ 对未包装的价值采取行动。 在这两种情况下，整个表达式的值都是可选值。Enumerations and Structures“Use enum to create an enumeration. Like classes and all other named types, enumerations can have methods associated with them.enum Rank: Int { case ace = 1 case two, three, four, five, six, seven, eight, nine, ten case jack, queen, king func simpleDescription() -&gt; String { switch self { case .ace: return &quot;ace&quot; case .jack: return &quot;jack&quot; case .queen: return &quot;queen&quot; case .king: return &quot;king&quot; default: return String(self.rawValue) } } } let ace = Rank.ace let aceRawValue = ace.rawValue” “By default, Swift assigns the raw values starting at zero and incrementing by one each time, but you can change this behavior by explicitly specifying values. In the example above, Ace is explicitly given a raw value of 1, and the rest of the raw values are assigned in order. You can also use strings or floating-point numbers as the raw type of an enumeration. Use the rawValue property to access the raw value of an enumeration case.Use the init?(rawValue:) initializer to make an instance of an enumeration from a raw value. It returns either the enumeration case matching the raw value or nil if there is no matching”if let convertedRank = Rank(rawValue: 3) { let threeDescription = convertedRank.simpleDescription() }” “The case values of an enumeration are actual values, not just another way of writing their raw values. In fact, in cases where there isn’t a meaningful raw value, you don’t have to provide one.enum Suit { case spades, hearts, diamonds, clubs func simpleDescription() -&gt; String { switch self { case .spades: return &quot;spades&quot; case .hearts: return &quot;hearts&quot; case .diamonds: return &quot;diamonds&quot; case .clubs: return &quot;clubs&quot; } } } let hearts = Suit.hearts let heartsDescription = hearts.simpleDescription()” 不一定设置原始值“Notice the two ways that the hearts case of the enumeration is referred to above: When assigning a value to the hearts constant, the enumeration case Suit.hearts is referred to by its full name because the constant doesn’t have an explicit type specified. Inside the switch, the enumeration case is referred to by the abbreviated form .hearts because the value of self is already known to be a suit. You can use the abbreviated form anytime the value’s type is already known.”“If an enumeration has raw values, those values are determined as part of the declaration, which means every instance of a particular enumeration case always has the same raw value. Another choice for enumeration cases is to have values associated with the case—these values are determined when you make the instance, and they can be different for each instance of an enumeration case. You can think of the associated values as behaving like stored properties of the enumeration case instance. For example, consider the case of requesting the sunrise and sunset times from a server. The server either responds with the requested information, or it responds with a description of what went wrong.enum ServerResponse { case result(String, String) case failure(String) } let success = ServerResponse.result(&quot;6:00 am&quot;, &quot;8:09 pm&quot;) let failure = ServerResponse.failure(&quot;Out of cheese.&quot;) switch success { case let .result(sunrise, sunset): print(&quot;Sunrise is at \\(sunrise) and sunset is at \\(sunset).&quot;) case let .failure(message): print(&quot;Failure... \\(message)&quot;) }” “如果枚举具有原始值，则这些值将作为声明的一部分确定，这意味着特定枚举情况的每个实例始终具有相同的原始值。枚举情况的另一个选择是使值与案例相关联 - 这些值在您创建实例时确定，并且对于枚举案例的每个实例它们可以不同。您可以将关联值视为与枚举案例实例的存储属性相似。例如，考虑从服务器请求日出和日落时间的情况。服务器响应所请求的信息，或者响应错误的描述。“Notice how the sunrise and sunset times are extracted from the ServerResponse value as part of matching the value against the switch cases.Use struct to create a structure. Structures support many of the same behaviors as classes, including methods and initializers. One of the most important differences between structures and classes is that structures are always copied when they are passed around in your code, but classes are passed by reference.”“struct Card { var rank: Rank var suit: Suit func simpleDescription() -&gt; String { return &quot;The \\(rank.simpleDescription()) of \\(suit.simpleDescription())&quot; } } let threeOfSpades = Card(rank: .three, suit: .spades) let threeOfSpadesDescription = threeOfSpades.simpleDescription()” Protocols and Extensions#####“Use protocol to declare a protocol. protocol ExampleProtocol { var simpleDescription: String { get } mutating func adjust() } Classes, enumerations, and structs can all adopt protocols.class SimpleClass: ExampleProtocol { var simpleDescription: String = &quot;A very simple class.&quot; var anotherProperty: Int = 69105 func adjust() { simpleDescription += &quot; Now 100% adjusted.&quot; } } var a = SimpleClass() a.adjust() let aDescription = a.simpleDescription struct SimpleStructure: ExampleProtocol { var simpleDescription: String = &quot;A simple structure&quot; mutating func adjust() { simpleDescription += &quot; (adjusted)&quot; } } var b = SimpleStructure() b.adjust() let bDescription = b.simpleDescription” “Notice the use of the mutating keyword in the declaration of SimpleStructure to mark a method that modifies the structure. The declaration of SimpleClass doesn’t need any of its methods marked as mutating because methods on a class can always modify the class.“请注意，在SimpleStructure声明中使用mutating关键字来标记修改结构的方法。 SimpleClass的声明不需要任何标记为变异的方法，因为类上的方法总是可以修改类。Use ext ension to add functionality to an existing type, such as new methods and computed properties. You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.”“extension Int: ExampleProtocol { var simpleDescription: String { return &quot;The number \\(self)&quot; } mutating func adjust() { self += 42 } } print(7.simpleDescription)” 使用扩展向现有类型添加功能，例如新方法和计算属性。 您可以使用扩展来将协议一致性添加到在其他地方声明的类型，甚至是从库或框架中导入的类型。”“You can use a protocol name just like any other named type—for example, to create a collection of objects that have different types but that all conform to a single protocol. When you work with values whose type is a protocol type, methods outside the protocol definition are not available.let protocolVlet protocolValue: ExampleProtocol = a print(protocolValue.simpleDescription) // print(protocolValue.anotherProperty) // Uncomment to see the error “您可以像使用任何其他命名类型一样使用协议名称 - 例如，创建具有不同类型但都符合单个协议的对象集合。 使用类型为协议类型的值时，协议定义之外的方法不可用。Even though the variable protocolValue has a runtime type of SimpleClass, the compiler treats it as the given type of ExampleProtocol. This means that you can’t accidentally access methods or properties that the class implements in addition to its protocol conformance.”即使变量protocolValue具有SimpleClass的运行时类型，编译器也会将其视为给定类型的ExampleProtocol。 这意味着除了协议一致性之外，您不会意外地访问该类实现的方法或属性。”Error Handling“You represent errors using any type that adopts the Error protocol.”“enum PrinterError: Error { case outOfPaper case noToner case onFire }” “Use throw to throw an error and throws to mark a function that can throw an error. If you throw an error in a function, the function returns immediately and the code that called the function handles the error.”“func send(job: Int, toPrinter printerName: String) throws -&gt; String { if printerName == &quot;Never Has Toner&quot; { throw PrinterError.noToner } return &quot;Job sent&quot; }” “There are several ways to handle errors. One way is to use do-catch. Inside the do block, you mark code that can throw an error by writing try in front of it. Inside the catch block, the error is automatically given the name error unless you give it a different name.”“do { let printerResponse = try send(job: 1040, toPrinter: &quot;Bi Sheng&quot;) print(printerResponse) } catch { print(error) }” “You can provide multiple catch blocks that handle specific errors. You write a pattern after catch just as you do after case in a switch.”“do { let printerResponse = try send(job: 1440, toPrinter: &quot;Gutenberg&quot;) print(printerResponse) } catch PrinterError.onFire { print(&quot;I&apos;ll just put this over here, with the rest of the fire.&quot;) } catch let printerError as PrinterError { print(&quot;Printer error: \\(printerError).&quot;) } catch { print(error) }” “Another way to handle errors is to use try? to convert the result to an optional. If the function throws an error, the specific error is discarded and the result is nil. Otherwise, the result is an optional containing the value that the function returned.”“let printerSuccess = try? send(job: 1884, toPrinter: &quot;Mergenthaler&quot;) let printerFailure = try? send(job: 1885, toPrinter: &quot;Never Has Toner&quot;)” “处理错误的另一种方法是使用try？ 将结果转换为可选。 如果函数抛出错误，则丢弃特定错误，结果为nil。 否则，结果是一个可选的，包含函数返回的值。”“Use defer to write a block of code that is executed after all other code in the function, just before the function returns. The code is executed regardless of whether the function throws an error. You can use defer to write setup and cleanup code next to each other, even though they need to be executed at different times.”“var fridgeIsOpen = false let fridgeContent = [&quot;milk&quot;, &quot;eggs&quot;, &quot;leftovers&quot;] func fridgeContains(_ food: String) -&gt; Bool { fridgeIsOpen = true defer { fridgeIsOpen = false } let result = fridgeContent.contains(food) return result } fridgeContains(&quot;banana&quot;) print(fridgeIsOpen)” “使用defer编写一个代码块，该代码块在函数中的所有其他代码之后执行，就在函数返回之前。 无论函数是否抛出错误，都会执行代码。 你可以使用defer来编写彼此相邻的设置和清理代码，即使它们需要在不同的时间执行。”Generics“Write a name inside angle brackets to make a generic function or type.func makeArray&lt;Item&gt;(repeating item: Item, numberOfTimes: Int) -&gt; [Item] { var result = [Item]() for _ in 0..&lt;numberOfTimes { result.append(item) } return result } makeArray(repeating: &quot;knock&quot;, numberOfTimes: 4)” “You can make generic forms of functions and methods, as well as classes, enumerations, and structures.// Reimplement the Swift standard library&apos;s optional type enum OptionalValue&lt;Wrapped&gt; { case none case some(Wrapped) } var possibleInteger: OptionalValue&lt;Int&gt; = .none possibleInteger = .some(100)” “Use where right before the body to specify a list of requirements—for example, to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.func anyCommonElements&lt;T: Sequence, U: Sequence&gt;(_ lhs: T, _ rhs: U) -&gt; Bool where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element { for lhsItem in lhs { for rhsItem in rhs { if lhsItem == rhsItem { return true } } } return false } anyCommonElements([1, 2, 3], [3])” “Writing &lt;T: Equatable&gt; is the same as writing … where T: Equatable.”","tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"教你如何轻松搭建属于自己的博客","date":"2018-09-07T01:29:56.000Z","path":"2018/09/07/教你如何轻松搭建属于自己的博客/","text":"一，Mac下利用Hexo+GitHub轻松搭建自己的博客Hexo安装1，基本流程：1.hexo是基于node.js的，所以需要安装node.js，而安装node.js最好选择homebrew2.homebrew安装需要依赖ruby3.安装顺序：homebrew—-&gt;node.js—-&gt;hexo2，具体安装流程：1,检查安装ruby终端命令：检查是否安装rubyruby -v 如果显示ruby的版本，说明电脑已经安装了ruby。否则，需要安装ruby。2,安装homebrew终端命令：ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 3,安装nodejs终端命令：brew install node 在安装nodejs过程中，提示如下警告：You have Xcode 8 installed without the CLT; 根据提示进行安装4，安装hexo终端命令:sudo npm install -g hexo Hexo安装成功本地工作空间1，创建本地文件夹，在该文件夹中启动Hexo工作，注意自己注意创建的目录：mkdir blog 新建文件 cd blog 打开新建的文件 hexo init 在当前文件夹中初始化hexo 2，我们先不写东西，只是生成hexo默认的一个界面，看下效果：hexo generate /** 生成一套静态网页 **/ hexo server /** 在服务器上运行 **/ 3，在浏览器中打开下面的地址，就可以看到默认的界面主页http://localhost:4000 本地工作空间创建完毕关联到GitHub1，我们先不急着写博客，先解决一个问题，就是本地创建的博客文件，如何同步到GitHub中？这里有一种比较方便的方法，可以自动同步你的文件到GitHub。那就是使用Hexo的配置文件来处理。Hexo的每一个功能的配置文件都是_config.yml， 具体说明看下面的注解： # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site ##修改以适应搜索引擎的收录 title: Hexo ##定义网站的标题 subtitle: ##定义网站的副标题 description: ##定义网站的描述 author: jason jwl ##定义网站的负责人 language: ##定义网站的语言,默认zh-Hans timezone: ##定义网站的时区 # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://yoursite.com ##定义网站访问的域名 root: / ##定义所在Web文件夹在哪个目录 permalink: :year/:month/:day/:title/ ##定义时间格式 permalink_defaults: # Directory source_dir: source ##定义从哪个文件夹获取博客资料 public_dir: public ##定义生成静态网站到哪个文件夹 archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 10 ##定义每一页多少条博客 pagination_dir: page # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: landscape ##定义使用的主题 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: 那么，如何实现文件自动同步呢？注意配置文件的最后一部分，我们将在那里配置GitHub。deploy: type: git repo: https://github.com/xxx/xxx.github.io.git branch: master （xxx为个人github的name） 关联到GitHub完成让我们来创建一篇自己的博客吧首先进入终端，使用cd命令进入到有Hexo框架的目录里面（bolg），输入：hexo new post &quot;我的第一篇博客&quot; (注意，该文件可以使用Markdown的编辑文件编辑，Hexo会自动转化为静态页面) 然后输入：hexo generate 或者 hexo g / 生成一套静态网页 /最后将该页面同步到GitHub上去，输入Hexo deploy 或者 Hexo d,该静态页面就会同步到GitHub上。创建一篇自己的博客完成如何访问GitHub上的静态页面呢从《本地工作空间》我们知道，可以在自己电脑上启动Hexo服务器，然后通过固定的地址就可以看到我们自己定义的界面。我们后来自己创建的博客也会出现在这个界面，但毕竟是我们本地的服务器，访问上很不方便。如何让远在五湖四海的兄弟都能看到你最新的博客呢？对，答案就是将Hexo生成的静态页面托管到GitHub上。上面的工作，我们已经顺利的将静态页面托管到了GitHub上，接下来就是如何访问他们了？创建自己的GitHub Pages创建自己的GitHub Pages完成快速、简洁且高效的博客框架Hexo官网：https://hexo.io/zh-cn/ 一款比较漂亮的博客主题资源地址themes资源地址theme","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]